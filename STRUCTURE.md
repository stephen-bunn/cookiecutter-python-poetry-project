# Python Package Structure

The project structure generated by this template contains various configuration files, folder structure standards, and project automation tooling that many developers new to Python may be unfamiliar with. The following sections detail the files, tools and their respective purposes for the generated project.

## Project Structure

The following sections detail the specific files and directories generated by this project template.

### `.github/`

This dotted folder contains GitHub specific configuration such as repository templates for issues and pull requests found in the `ISSUE_TEMPLATE` directory and in the `PULL_REQUEST_TEMPLATE` file. You can read up more on these repository-local templates in [GitHub’s documentation.](https://help.github.com/en/github/building-a-strong-community/using-templates-to-encourage-useful-issues-and-pull-requests)

This GitHub configuration folder also includes [GitHub actions](https://github.com/features/actions) task definitions in the `workflows/` child folder. Included in this folder are task definitions for testing the package can be built successfully and that running the full provided test suite against Python 3.6 and 3.7 on the latest builds of MacOS, Windows, and Ubuntu is successful. If you want to use a different provider for basic CI / CD, I would recommend disabling these actions as they are only present to provide an easy and cheap CI pipeline (close to the codebase) for commits and PRs.

### `docs/`

[Sphinx](https://www.sphinx-doc.org/en/master/)-style documentation via [reStructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html) for the entire project is found in the `source/` child folder. During documentation generation, a `dist/` child folder will be created containing the built static HTML content that is typically used for [Read the Docs](https://readthedocs.org/) style documentation.

Along with this, we strongly encourage utilizing Sphinx-style docstrings in your source code so that Sphinx’s builtin plugin [`sphinx.ext.autodoc`](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html) can automatically include your docstrings as part of your package documentation. This project is automatically configured to run autodoc when building documentation with the source code discoverable within the `src/` folder.

### `changes/`

News fragment files for use when generating a new version bump and release in order to populate `CHANGELOG.rst` with noteworthy changes. News fragments are simply files with specific extensions such as `.feature`, `.bugfix`, `.removal`, `.deprecated`, etc. The tool that automatically generates our changelogs is [Towncrier](https://towncrier.readthedocs.io/en/actual-freaking-docs/index.html) and is regarded as the simplest itreation for proper changelog management.

To learn more about how to use Towncrier, please read through the generated `CONTRIBUTING.rst` documentation on “Changelog Mangaement”.

This directory contains a blank `!.gitignore` to ensure that this folder is persisted in git’s history even if the directory is empty. Although it is technically safe to remove this git configuration file, I would recommend you leave it as a measure for keeping your git history consistent.

### `src/`

The source folder is where all the source code for your installable Python module should live.

Typically you will see many Python projects dumping their modules in the root of their repository. Although that works, it isn’t a great practice. Including all of your project’s source code in an explicit folder structure [improves the process of testing and packaging](https://hynek.me/articles/testing-packaging/) with Python’s existing tooling. *Plus it’s nice to avoid throwing a whole ton of modules in the root of a repository.*

### `tasks/`

All project automation tooling and utilites should be contained to the `tasks/` folder. The gerated project utilizes the popular [Invoke](http://www.pyinvoke.org/) task execution package. The existing tasks that are provided within this folder are executable by using the installed `invoke` (also aliased to `inv`) utility within the created development virtual environment. Note that you will only be able to access the `invoke` utility within the virutal environment created by the package manager unless you install `invoke` as a user-level dependency through `pip` outisde of the virtual environment.

 Below is a list of provided Invoke-able tasks.

```console
$ invoke -l
Available tasks:

  build                  Build the project.
  clean                  Clean the project.
  profile                Run and profile a given Python script.
  test                   Test the project.
  docs.build             Build docs.
  docs.build-news        Build towncrier newsfragments.
  docs.clean             Clean built docs.
  docs.view              Build and view docs.
  package.build          Build pacakge source files.
  package.check          Check built package is valid.
  package.clean          Clean previously built package artifacts.
  package.format         Auto format package source files.
  package.requirements   Generate requirements.txt from Poetry's lock.
  package.stub           Generate typing stubs for the package.
  package.test           Run package tests.
  package.typecheck      Run type checking with generated package stubs.
```

### `tests/`

All tests related to the source code provided in the `src/` directory should be organized and developed in the isolated `tests/` folder. The default testing framework that is installed and configured by this project template is the most widely supported testing framework [`pytest`](https://docs.pytest.org/en/latest/).

Along with this, this project generates two small sample tests to ensure that the testing framework works out of the box. Also, the following pytest plugins are installed to make tests easier to write, run, and debug:

- [`hypothesis`](https://hypothesis.works/) - *For clean, easy, and optimal property-based testing*
- [`pytest-flake8`](https://pypi.org/project/pytest-flake8/) - *For ensuring that flake8 standards are followed on the same level as tests*
- [`pytest-sugar`](https://pypi.org/project/pytest-sugar/) - *For making the user-experience of pytest a bit nicer*
- [`pytest-xdist`](https://pypi.org/project/pytest-xdist/) - *For proper test parallelization*
- [`pytest-cov`](https://pypi.org/project/pytest-cov/) - *For captured test coverage reports through [coverage](https://pypi.org/project/coverage/)*

### `.editorconfig`

The very common [EditorConfig](https://editorconfig.org/) configuration to support the different file types used primarily with the generated project structure. This configuration file specifies the different settings that should be applied to your editor (line endings, character encoding, identation style, indentation size, etc.) for different file types.

It’s recommended that all contributors to the codebase standardize on the settings provided by this configuration. To see if your prefered editor supports this configuration natively or if you need to install a lightweight plugin, checkout [EditorConfig’s support documentation](https://editorconfig.org/#download).

### `.gitignore`

The common git ingored globs for a standard Python project as generated by [`gitignore.io`](https://gitignore.io/). Includes some additional tweaks that play nicely with the included project tooling and standards.

### `.pre-commit-config.yaml`

Defines the [`pre-commit`](https://pre-commit.com/) hooks for code formatters, linters, type checkers that ensure code quality standards per every changeset that gets commited.

During project generation with cookiecutter, these commit hooks are installed into the created git repository. So right out of the box, your changes should be checked with each of the defined hooks before they allowed to become commits.

- To uninstall these commit hooks, you can run `pre-commit uninstall`

- To skip these hooks from running against a `git commit`, you can run `git commit --no-verify` instead.
- To run these hooks against your specific files without making a change and doing a `git commit`, you can run `pre-commit run --files ./src/path_to_the_file.py`

### `.readthedocs.yml`

Defines configuration specific to [Read the Docs](https://readthedocs.org/) for building and rendering our provided documentation in `docs/`. Unfortunately, since Read the Docs is a bit behind the times, they require a `requirements.txt` to install dependencies from when building documentation. The best solution is to keep a `requirements.txt` file specifically for Read the Docs (if using their documentation hosting).

To make the process of dependency freezing a bit more stable, you can utilize the included project automation task `invoke package.requirements` which will generate the **explictly-correct** `requirements.txt` for Read the Docs to install dependencies from.

### `CHANGELOG.rst`

The changelog based on [keep a changelog](https://keepachangelog.com/en/1.0.0/) which is auto generated with news fragments found in `news/` by the [Towncrier](https://towncrier.readthedocs.io/en/actual-freaking-docs/index.html) tool. This file always has some header content with a small blurb about the standards of the changelog file itself, and a reStructuredText marker where the Towncrier utility will insert generated changelogs upon relases.

This marker looks like this and should never be removed:

```reStructuredText
.. towncrier release notes start
```

### `CONTRIBUTING.rst`

The general usage guidelines for new contributors to read through in order to understand how to make changes to the project. This document is typically not updated very much but is the standard for new engineers to discover how to get involved in a project.

### `LICENSE`

Typically the `LICENSE` file is self explanatory and contains the content of an OSI approved license for open source projects. However, since most of the things we develop are proprietary, the common content you will see in this file is a copy prohibition disclaimer.

If this template is used to build an open source project, please be sure to use a permissive license such as [MIT](https://choosealicense.com/licenses/mit/) or [ISC](https://choosealicense.com/licenses/isc/) instead of the one included.

### `pyproject.toml`

As defined by [PEP-518](https://www.python.org/dev/peps/pep-0518/) the new packaging build system and all tooling configurations should be stored in `pyproject.toml` file in the root of your project. However, since many tools are dragging their feet on updating their configuration loaders to read from `toml` files (which currently have no builtin parser), we have opted to only include the configuration for tools that **only** support it.

Currently build and development dependencies are managed via [Poetry](https://python-poetry.org/).
Poetry utilizies the `pyproject.toml` file for storing these dependencies along with the various configuration necessary for building and publishing a Python project to PyPi.

Currently the configurations for [black](https://black.readthedocs.io/en/stable/) and [Towncirer](https://towncrier.readthedocs.io/en/actual-freaking-docs/index.html) are included in this file as well as the bulitin support for the specification of the Python packaging build system. Once more tools add suport for loading configuration from this file, we should migrate configs over from `setup.cfg`.

### `README.md`

The `README.md` contains the top-level introductory documentation for your project. This file is what is rendered in GitHub as a first-look into how to use the project. I find that this file typically should contain some introductory documentation on “Getting Started” with your project. More intricate documentation belongs as part of the generated documentation in `docs/`.

### `setup.cfg`

You will typically see packaging handled mainly through `setup.py`. However, including parsing and building logic within the `setup.py` script is **highly discouraged** as it causes many issues in `pip` and other dependency installers.
Until `pyproject.toml` becomes the supported standard, [`setup.cfg` should be used for declaring the metadata of your package](https://docs.python.org/3/distutils/configfile.html) and all tooling that doesn’t already support `pyproject.toml`.

You will find configuration for many utilities within this file under their own specified section headings.
Configuration for tools that currently don't support `pyproject.toml` such as `flake8`, `isort`, and `mypy` are currently included in this project template.

## Project Tooling

The following sections detail the specific tools taken advantage of by this project template.

### [`poetry`](https://python-poetry.org/)

Poetry is a virtual environment / dependency management utility that is supported on all shells and utilizes a PyPi optimized dependency-resolver.
This tool allows you to manage your project’s production and development dependencies with lock files and local virtual environments.

*In the future, switching dependency managers, should be just as easy as switching from [`npm`](https://www.npmjs.com/) to [`yarn`](https://yarnpkg.com/).*

### [`sphinx`](https://www.sphinx-doc.org/en/master/index.html)

Sphinx is the standard documentation builder for Python projects and expected from popular documentation hosts such as [Read the Docs](https://readthedocs.org/). Based on [reStructuredText markdown](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html), this documentation builder allows rich markdown editing and expects you to be precise with what you write.

Sphinx has built-in support for cross-referencing documentation from other projects and can be used to quickly auto-generate documentation for your project’s code. By reading Sphinx-stylized docstrings, the `sphinx.ext.autodoc` module can build an entire reference guide to your codebase.

### [`towncrier`](https://towncrier.readthedocs.io/en/actual-freaking-docs/)

There are not many utilities that deal with proper changelog management, the best one available built with Python is Towncrier. This utility is used for taking news fragment files and generating a clean and readable changelog for when a project’s version is bumped and released. This utility is used by some of the best structured Python packages out there and is a good choice for maintaining changelogs.

Usage of this tool is very straight-forward, and with this project template, most everything is pre-configured to work right away. Simply drop your news fragments in the `news/` directory and run the `docs.build-news` script to generate updates to the existing `CHANGELOG.rst`.

### [`pre-commit`](https://pre-commit.com/)

Pre-commit is a unified tool that handles defining and install Git pre-commit hooks. These hooks are typically run to do initial quality control on changesets about to be committed.

#### [`black`](https://black.readthedocs.io/en/stable/)

Black is an uncompromising opinionated code-formatter that automatically applies a [PEP-8](https://www.python.org/dev/peps/pep-0008/) compatible spec to your code. We use Black as a pre-commit hook to ensure style standards are consistent throughout all commits. I also recommend that you use Black within your editor as having your code be auto-formatted after saves removes the slight mental strain required when the Black pre-commit hook updates something it finds wrong in your changeset.

We use this auto-formatter to avoid having to define a style specification. Since this is always a source of contention. It’s just massively easier to “let the robot do it."

#### [`isort`](https://isort.readthedocs.io/en/latest/)

ISort is simply a tool used to properly sort imports within Python source code. When source files inevitably get larger, more imports are typically defined. By sorting your imports consistently throughout your codebase, it becomes trivial to determine  what packages are necessary in a file.

#### [`flake8`](https://flake8.pycqa.org/en/latest/)

Flake8 is the most widely used linter as it applies linting rules from the [PEP-8](https://www.python.org/dev/peps/pep-0008/) and many other common syntax and language errors / warnings. We apply this tool as a pre-commit hook to ensure that commited changesets are always free of the common issues flake8 looks for.

In our project template we are explicitly ignoring several rules that either conflict with `black` styling, or are considered deprecated. See the `[flake8]` section in `setup.cfg` for more details.

#### [`mypy`](http://mypy-lang.org/)

Since we are writing Python 3.6+ nowadays, we should be typing most if not all of our code. Static typechecking is a great help for ensuring that developers understand what they are writing while they are writing it. The MyPy static typechecking tool, runs as a pre-commit hook to make sure that our declared typings make sense with how we are using them in the runtime.

### [`pytest`](https://docs.pytest.org/en/latest/)

Pytest is the modernized testing framework that supports many contributor plugins, explicit fixtures, marked / categorized tests, and many more features. This is a massive step up from using the builtin `unittest` module.

#### [`hypothesis`](https://hypothesis.works/)

Hypothesis is a property-based testing framework inspired from [Haskell’s QuickCheck](https://hackage.haskell.org/package/QuickCheck). This framework plugs directly into Pytest and allows us to do generative testing to quickly and efficiently discover edge-cases way faster than writing lazy `x = y` unittests.

#### [`coverage`](https://coverage.readthedocs.io/en/coverage-5.0.3/)

Coverage simply is a plugable component into Pytest that records Python branch coverage that your tests exercise. Configuration for coverage is provided by default in the generated project template, so new tests should automatically report coverage on new functionality.

### [`invoke`](http://www.pyinvoke.org/)

Invoke is a standard local tasking framework typically used for defining quick maintinence commands that are composable and can be executed quickly and easily from the command-line. We utilize this tool to build our project automation tasks with.
